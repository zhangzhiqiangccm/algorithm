## 动态规划

动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解
法。

### 主要思想

若要解一个给定问题，我们需要解其不同部分（子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，如斐波拉锲数列，如果用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。

动态规划法仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。

一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解的时候直接查表。

### 动态规划模板步骤

* 确定动态规划状态
* 写出状态转移方程（画出状态转移表）
* 考虑初始化条件
* 考虑输出状态
* 考虑对时空复杂度的优化



### Leetcode300:最长上升子序列

#### 题目描述

给定一个无序的整数数组，找到其中最长上升子序列的长度。如数组[10,9,2,4,3,7,101,18]，输出为4，最长的上升子序列是[2,3,7,101]，长度是4。

#### 解题思路

第一步：确定动态规划状态

* 是否存在状态转移？
* 什么样的状态比较好转移，找到对求解问题最方便的状态转移？

这个题目可以使用一个一维数组dp来存储转移状态，dp[i]可以定义为以num[i]这个数结尾的最长递增子序列的长度。如，在nums[10,9,2,5,3,7,101,18]这个数组中，dp[0]是数字10的最长递增子序列的长度，也就是1（本身）。dp[5]为数字7对应的最长递增子序列长度，也就是[2,5,7]或者[2,3,7]，长度为3。

第二步：写出一个好的状态转移方程

* 使用数学归纳法

我们如何得到dp[5] = 3的呢：既然是递增的子序列，我们只需要找到num[5]前面比7小的子序列，然后把7接到最后，就可以形成一个新的递增的子序列，也就是这个新的子序列是前面那些数加上7，相当于长度+1.当然也是有可能找到许多不同的子序列。总而言之，比较当前dp[i]的长度和dp[i]对应产生新的子序列长度，这里我们用j来表示所有比i小的数组中的索引，代码如下：

```python
for i in range(len(nums)):
    for j in range(i):
        if num[i] > num[j]:
            dp[i] = max(dp[i],dp[j]+1)
```

tips:在实际问题中，如果不能很快找出递推公式可以写出前几项，然后归纳总结。如果还不行可能是dp数组定义得不恰当，需要回到第一步重新定义。或者说dp数组存储得信息还不够，需要二维数组或者三位数组。

第三步：考虑初始条件

边界值主要考虑三个地方：

* dp数组整体得初始值
* dp数组（二维）i=0和j=0的地方
* dp存放状态的长度，是整个数组的长度还是数组长度加一。

在这个问题中，子序列最少就是自己，长度为1，这样我们可以将所有的dp初始化为1，再考虑长度问题，由于dp[i]代表的是nums[i]的最长子序列长度，所以并不需要加一。所以用代码表示就是dp = [1]*len(nums)

* 产生一个全为1，长度为n的数组

```python
dp = [1 for _ in range(n)]
dp = [1]*n
```

* 产生一个长度为m，宽度为n，全为0的二维矩阵：

```python
dp = [[0 for _ in range(n)] for _ in range(m)]
dp = [[0]*n for _ in range(m)]
```

第四步：考虑输出状态

对于具体问题，我们需要知道dp数组中存储的是哪些值，最后我们需要的是数组中的哪些值：

* 返回dp数组中最后一个值作为输入，一般对应二维dp问题
* 返回dp数组中最大的那个数字，一般对应记录最大值问题
* 返回保存的最大值，一般是maxval = max(maxval,dp[i])这样的形式

tips:这个公式必须是在满足递增的条件下，也就是nums[i]>nums[j]的条件下才能城里，但是并不是num[i]前面的所有数字都是满足条件的，所以接下来的输出应该是max(dp) 而不是dp[-1]，原因是dp数组由于计算递增的子序列长度，所以dp数组里可能会有值是比最后遍历的数值大的情况，每次遍历nums[j]所对应的位置都是比nums[i]小的那个数。

最后加上数组是否为空的判断条件：

```python
def lengthoflis(self,nums:List[int]) -> int:
    if not nums:return 0
    dp = [1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i],dp[j]+1)
                returun max(dp)
```

#### 模板总结

```python
for i in range(len(nums)):
    for i in range(i):
        dp[i] = 最值(dp[i],dp[j]+···)
```

